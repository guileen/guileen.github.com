---
title: 幂等性和非幂等性操作
layout: post
published: false
categories:
tags: [architecture]
---
感谢hprose 作者 @andot 给我科普了幂等性和非幂等性的概念。这是由以下问题的讨论开始的。

Socket协议，客户端发消息，server收到消息。server返回，网络传输失败。 客户端超时，客户端重发消息，server再次收到重复消息。请问，这个时候，服务器端应该怎么处理？
业务不可以被执行两次，比如，这个消息是花金币买道具。

你应该把请求分为幂等性请求和非幂等性请求，对于幂等性请求，就可以重复执行。 对于非幂等性请求，网络中断之后，客户端需要使用一个幂等性请求来查询刚才那个请求的执行状态
然后再决定是否重发请求。

也就是说，这个事，不需要我的rpc框架层关心。而是逻辑层关心的事。

在实际使用中，就以买道具为例

比如 buy item1 with 1000 coin
客户端断线重连后要查询这个事的执行状态发送一个请求
那么还是要在购买之前就在客户端生成一个  交易id

买道具这个问题这样做，首先调用一个查询现在状态的API，然后发送买道具请求，如果成功，就什么都不用管。如果失败了。就再调用那个查询状态的API，跟之前查询的结果作比较，如果结果已经不一样了。就不重发，如果结果跟原来一样，再重发买道具请求。

这种方式是通用的

这个状态应该是 该道具的数量！

嗯，这个状态和比较的条件是什么就有用户需要来决定了。

这种方式当然也不是100%可靠，那就是服务器端本身再执行请求的时候，执行到一半死了，留了脏数据。
查询脏数据得到的状态跟原来查询的状态虽然不一致，但也不是对的。

所以这个时候，如果不重发请求，也不对，重发请求也不一定就对。

嗯，服务器bug那是没办法了。

再比如一个例子，聊天。A发消息给服务器，服务器告诉A收到，服务器发消息给B，B告诉服务器收到（这一步需要吗？）。服务器告诉A时，网络失败

聊天的这个。A重连时查询状态。
这个状态应该就是具体的消息ID了吧
但这种情况在实际中也是经常遇到的，反正这种东西都要自己做特殊处理。
其实聊天这个更简单
一般来说，聊天可以设置一个硬条件，就是同样的话，不允许重发。
在这个条件下，发送聊天消息就从一个非幂等性请求变成了一个幂等性请求了。
这个可能不合理啊
这样不管A重发还是不重发，服务器端都可以正常处理。
对于聊天，是合理的，避免刷屏嘛
比如，嗯，哦，之类的，重复概率是很高的，可以设置连续两条不可以重复
就是连续的两条啊
我开头说的不够清楚，哈哈

比如我在微信上， A，B,C 3条消息都失败了。我手动重发
这么说，A 失败，B成功。这时候选择重发A，先要查询A有没有发送成功，。。
不对，微信这个情况可能是这样
A发送，转圈，网络失败。会一直转圈，并不断查询状态直到确认发送成功或发送失败。所以当我在界面上看到失败时，那是真的失败了。

我觉得聊天这种事吧，虽然完全避免消息被重复是可以做到的，但就算做不到，也没有太大关系，跟交易系统比起来，这个是允许重复的。
所以，在这种事情上，没有必要做的太严格，在不影响性能的情况下，能尽量避免就行了。不需要像交易系统那样严格。

嗯，不错，学习了。web开发也是同样的道理，理论上也会有同样的问题，只是很少有类似“重试” 这样的设计，所以没有相应的问题

使用毫秒时间戳过滤重复消息，就是消息有个时间戳作为id
时间戳做sort也方便
没收到回执，会再发送，还带着当时的时间戳
就算消息在服务端转发丢失了，客户端还有重发机制，再加回执的处理
毫秒时间戳做当前用户消息的唯一性
对，带上时间戳，消息就成了幂等性的了
