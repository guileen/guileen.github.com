<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>桂糊涂的博客</title>
  
  <subtitle>代码杂记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://guileen.github.io/"/>
  <updated>2019-12-24T16:34:23.819Z</updated>
  <id>http://guileen.github.io/</id>
  
  <author>
    <name>桂糊涂</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Torch的损失函数和优化器</title>
    <link href="http://guileen.github.io/2019/12/24/torch-output-loss-optimizer/"/>
    <id>http://guileen.github.io/2019/12/24/torch-output-loss-optimizer/</id>
    <published>2019-12-24T14:05:59.000Z</published>
    <updated>2019-12-24T16:34:23.819Z</updated>
    
    <content type="html"><![CDATA[<p>深度神经网络输出的结果与标注结果进行对比，计算出损失，根据损失进行优化。那么输出结果、损失函数、优化方法就需要进行正确的选择。</p><h1 id="常用损失函数"><a href="#常用损失函数" class="headerlink" title="常用损失函数"></a>常用损失函数</h1><p>pytorch 损失函数的基本用法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">criterion = LossCriterion(参数)</span><br><span class="line">loss = criterion(x, y)</span><br></pre></td></tr></table></figure><p>Mean Absolute Error<br>torch.nn.L1Loss<br>Measures the mean absolute error.</p><h2 id="Mean-Absolute-Error-L1Loss"><a href="#Mean-Absolute-Error-L1Loss" class="headerlink" title="Mean Absolute Error/ L1Loss"></a>Mean Absolute Error/ L1Loss</h2><p>nn.L1Loss<br><img src="/img/loss/l1loss.png" alt=""><br>很少使用</p><h2 id="Mean-Square-Error-Loss"><a href="#Mean-Square-Error-Loss" class="headerlink" title="Mean Square Error Loss"></a>Mean Square Error Loss</h2><p>nn.MSELoss<br><img src="/img/loss/mseloss.png" alt=""><br>针对数值不大的回归问题。</p><h2 id="Smooth-L1-Loss"><a href="#Smooth-L1-Loss" class="headerlink" title="Smooth L1 Loss"></a>Smooth L1 Loss</h2><p>nn.SmoothL1Loss<br><img src="/img/loss/smoothl1loss.png" alt=""><br>它在绝对差值大于1时不求平方，可以避免梯度爆炸。大部分回归问题都可以适用，尤其是数值比较大的时候。</p><h2 id="Negative-Log-Likelihood-Loss"><a href="#Negative-Log-Likelihood-Loss" class="headerlink" title="Negative Log-Likelihood Loss"></a>Negative Log-Likelihood Loss</h2><p>torch.nn.NLLLoss，一般与 LogSoftmax 成对使用。使用时 <code>loss(softmaxTarget, target)</code>。用于处理多分类问题。<br><img src="/img/loss/nllloss.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">m = nn.LogSoftmax(dim=<span class="number">1</span>)</span><br><span class="line">loss = nn.NLLLoss()</span><br><span class="line"><span class="comment"># input is of size N x C = 3 x 5， C为分类数</span></span><br><span class="line">input = torch.randn(<span class="number">3</span>, <span class="number">5</span>, requires_grad=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># each element in target has to have 0 &lt;= value &lt; C</span></span><br><span class="line">target = torch.tensor([<span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>])</span><br><span class="line">output = loss(m(input), target)</span><br><span class="line">output.backward()</span><br></pre></td></tr></table></figure><h2 id="Cross-Entropy-Loss"><a href="#Cross-Entropy-Loss" class="headerlink" title="Cross Entropy Loss"></a>Cross Entropy Loss</h2><p>nn.CrossEntropyLoss 将 LogSoftmax 和 NLLLoss 绑定到了一起。所以无需再对结果使用Softmax</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loss &#x3D; nn.CrossEntropyLoss()</span><br><span class="line">input &#x3D; torch.randn(3, 5, requires_grad&#x3D;True)</span><br><span class="line">target &#x3D; torch.empty(3, dtype&#x3D;torch.long).random_(5)</span><br><span class="line">output &#x3D; loss(input, target)</span><br><span class="line">output.backward()</span><br></pre></td></tr></table></figure><h2 id="BCELoss"><a href="#BCELoss" class="headerlink" title="BCELoss"></a>BCELoss</h2><p>二分类问题的CrossEntropyLoss。输入、目标结构是一样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m = nn.Sigmoid()</span><br><span class="line">loss = nn.BCELoss()</span><br><span class="line">input = torch.randn(<span class="number">3</span>, requires_grad=<span class="keyword">True</span>)</span><br><span class="line">target = torch.empty(<span class="number">3</span>).random_(<span class="number">2</span>)</span><br><span class="line">output = loss(m(input), target)</span><br><span class="line">output.backward()</span><br></pre></td></tr></table></figure><h2 id="Margin-Ranking-Loss"><a href="#Margin-Ranking-Loss" class="headerlink" title="Margin Ranking Loss"></a>Margin Ranking Loss</h2><p><img src="/img/loss/marginrankingloss.png" alt=""></p><p>常用户增强学习、对抗生成网络、排序任务。给定输入x1，x2，y的值是1或-1，如果y==1表示x1应该比x2的排名更高，y==-1则相反。如果y值与x1、x2顺序一致，那么loss为0，否则错误为 y*(x1-x2)</p><h2 id="Hinge-Embedding-Loss"><a href="#Hinge-Embedding-Loss" class="headerlink" title="Hinge Embedding Loss"></a>Hinge Embedding Loss</h2><p>y的值是1或-1，用于衡量两个输入是否相似或不相似。</p><h2 id="Cosine-Embedding-Loss"><a href="#Cosine-Embedding-Loss" class="headerlink" title="Cosine Embedding Loss"></a>Cosine Embedding Loss</h2><p>给定两个输入x1，x2，y的值是1或-1，用于衡量x1和x2是否相似。<br><img src="/img/loss/cosineembeddingloss.png" alt=""><br>其中cos(x1, x2)表示相似度<br><img src="/img/loss/cossim.png" alt=""></p><h1 id="各种优化器"><a href="#各种优化器" class="headerlink" title="各种优化器"></a>各种优化器</h1><p>大多数情况Adam能够取得比较好的效果。SGD 是最普通的优化器, 也可以说没有加速效果, 而 Momentum 是 SGD 的改良版, 它加入了动量原则. 后面的 RMSprop 又是 Momentum 的升级版. 而 Adam 又是 RMSprop 的升级版. 不过从这个结果中我们看到, Adam 的效果似乎比 RMSprop 要差一点. 所以说并不是越先进的优化器, 结果越佳.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SGD 就是随机梯度下降</span></span><br><span class="line">opt_SGD         = torch.optim.SGD(net_SGD.parameters(), lr=LR)</span><br><span class="line"><span class="comment"># momentum 动量加速,在SGD函数里指定momentum的值即可</span></span><br><span class="line">opt_Momentum    = torch.optim.SGD(net_Momentum.parameters(), lr=LR, momentum=<span class="number">0.8</span>)</span><br><span class="line"><span class="comment"># RMSprop 指定参数alpha</span></span><br><span class="line">opt_RMSprop     = torch.optim.RMSprop(net_RMSprop.parameters(), lr=LR, alpha=<span class="number">0.9</span>)</span><br><span class="line"><span class="comment"># Adam 参数betas=(0.9, 0.99)</span></span><br><span class="line">opt_Adam        = torch.optim.Adam(net_Adam.parameters(), lr=LR, betas=(<span class="number">0.9</span>, <span class="number">0.99</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;深度神经网络输出的结果与标注结果进行对比，计算出损失，根据损失进行优化。那么输出结果、损失函数、优化方法就需要进行正确的选择。&lt;/p&gt;
&lt;h1 id=&quot;常用损失函数&quot;&gt;&lt;a href=&quot;#常用损失函数&quot; class=&quot;headerlink&quot; title=&quot;常用损失函数&quot;&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>理解CNN参数及PyTorch实例</title>
    <link href="http://guileen.github.io/2019/12/24/understanding-cnn/"/>
    <id>http://guileen.github.io/2019/12/24/understanding-cnn/</id>
    <published>2019-12-24T07:56:21.000Z</published>
    <updated>2019-12-24T11:10:54.647Z</updated>
    
    <content type="html"><![CDATA[<p>本文假设读者已经了解了CNN的基本原理。在实际的项目中，会发现CNN有多个参数需要调整，本文主要目的在于理清各个参数的作用。</p><h2 id="卷积核-kernel"><a href="#卷积核-kernel" class="headerlink" title="卷积核 kernel"></a>卷积核 kernel</h2><p>Kernel，卷积核，有时也称为filter。在迭代过程中，学习的结果就保存在kernel里面。深度学习，学习的就是一个权重。kernel的尺寸越小，计算量越小，一般选择3x3，更小就没有意义了。<br><img src="/img/cnn/kernel_2.png" alt=""></p><p>结果是对卷积核与一小块输入数据的点积。</p><h2 id="层数-Channels"><a href="#层数-Channels" class="headerlink" title="层数 Channels"></a>层数 Channels</h2><p><img src="/img/cnn/channel_1.png" alt=""></p><p>所有位置的点积构成一个激活层。</p><p><img src="/img/cnn/channel_2.png" alt=""></p><p>如果我们有6个卷积核，我们就会有6个激活层。</p><h2 id="步长-Stride"><a href="#步长-Stride" class="headerlink" title="步长 Stride"></a>步长 Stride</h2><p><img src="/img/cnn/kernel.gif" alt=""><br>上图是每次向右移动一格，一行结束向下移动一行，所以stride是1x1，如果是移动2格2行则是2x2。</p><h2 id="填充-Padding"><a href="#填充-Padding" class="headerlink" title="填充 Padding"></a>填充 Padding</h2><p>Padding的作用是为了获取图片上下左右边缘的特征。<br><img src="/img/cnn/pad.jpg" alt=""></p><h2 id="池化-Pooling"><a href="#池化-Pooling" class="headerlink" title="池化 Pooling"></a>池化 Pooling</h2><p>卷积层为了提取特征，但是卷积层提取完特征后特征图层依然很大。为了减少计算量，我们可以用padding的方式来减小特征图层。Pooling的方法有MaxPooling核AveragePooling。<br><img src="/img/cnn/pooling.jpg" alt=""></p><p>推荐看一下李飞飞的<a href="http://cs231n.stanford.edu/slides/2017/cs231n_2017_lecture5.pdf" target="_blank" rel="noopener">这篇slide</a></p><h2 id="PyTorch-中的相关方法"><a href="#PyTorch-中的相关方法" class="headerlink" title="PyTorch 中的相关方法"></a>PyTorch 中的相关方法</h2><ul><li><p>torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True, padding_mode=’zeros’)</p></li><li><p>torch.nn.MaxPool2d(kernel_size, stride=None, padding=0, dilation=1, return_indices=False, ceil_mode=False)</p><ul><li>stride 默认与kernel_size相等</li></ul></li><li><p>torch.nn.AvgPool2d(kernel_size, stride=None, padding=0, ceil_mode=False, count_include_pad=True, divisor_override=None)</p></li><li><p>Tensor.view(*shape) -&gt; Tensor</p><ul><li>用于将卷积层展开为全连接层<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x &#x3D; torch.randn(4, 4)</span><br><span class="line">&gt;&gt;&gt; x.size()</span><br><span class="line">torch.Size([4, 4])</span><br><span class="line">&gt;&gt;&gt; y &#x3D; x.view(16)</span><br><span class="line">&gt;&gt;&gt; y.size()</span><br><span class="line">torch.Size([16])</span><br><span class="line">&gt;&gt;&gt; z &#x3D; x.view(-1, 8)  # the size -1 is inferred from other dimensions</span><br><span class="line">&gt;&gt;&gt; z.size()</span><br><span class="line">torch.Size([2, 8])</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="MNIST例子"><a href="#MNIST例子" class="headerlink" title="MNIST例子"></a>MNIST例子</h2><p>MNIST 数据集的输入是 1x28x28 的数据集。在实际开发中必须要清楚每一次的输出结构。</p><ul><li>我们第一层使用 5x5的卷积核，步长为1，padding为0，28-5+1 = 24，那么输出就是 24x24。计算方法是 (input_size - kernel_size)/ stride + 1。</li><li>我们第二层使用 2x2的MaxPool，那么输出为 12x12.</li><li>第三层再使用5x5，卷积核，输出则为 12-5+1，即 8x8。</li><li>再使用 2x2 MaxPool，输出则为 4x4。</li></ul><p><img src="/img/cnn/mnist_convet.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="string">"""ConvNet -&gt; Max_Pool -&gt; RELU -&gt; ConvNet -&gt; Max_Pool -&gt; RELU -&gt; FC -&gt; RELU -&gt; FC -&gt; SOFTMAX"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Net, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">1</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">10</span>, <span class="number">20</span>, <span class="number">5</span>, <span class="number">1</span>)</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">4</span>*<span class="number">4</span>*<span class="number">20</span>, <span class="number">50</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">50</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = F.relu(self.conv1(x))</span><br><span class="line">        x = F.max_pool2d(x, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">        x = F.relu(self.conv2(x))</span><br><span class="line">        x = F.max_pool2d(x, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">        x = x.view(<span class="number">-1</span>, <span class="number">4</span>*<span class="number">4</span>*<span class="number">20</span>)</span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        <span class="keyword">return</span> F.log_softmax(x, dim=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>以上代码摘自 <a href="https://github.com/floydhub/mnist" target="_blank" rel="noopener">https://github.com/floydhub/mnist</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文假设读者已经了解了CNN的基本原理。在实际的项目中，会发现CNN有多个参数需要调整，本文主要目的在于理清各个参数的作用。&lt;/p&gt;
&lt;h2 id=&quot;卷积核-kernel&quot;&gt;&lt;a href=&quot;#卷积核-kernel&quot; class=&quot;headerlink&quot; title=&quot;卷积
      
    
    </summary>
    
    
      <category term="machine-learning" scheme="http://guileen.github.io/tags/machine-learning/"/>
    
      <category term="AI" scheme="http://guileen.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>AlphaGo Zero 工作原理</title>
    <link href="http://guileen.github.io/2019/11/01/alpha-go-zero/"/>
    <id>http://guileen.github.io/2019/11/01/alpha-go-zero/</id>
    <published>2019-10-31T17:00:00.000Z</published>
    <updated>2019-12-24T11:10:49.120Z</updated>
    
    <content type="html"><![CDATA[<p>本文写于2017年12月，获<a href="https://zhuanlan.zhihu.com/p/32952677" target="_blank" rel="noopener">Udacity专栏转载</a>。今将其搬运至我的博客。</p><p>2016年3月，Alpha Go Master击败最强的人类围棋选手之一李世石。击败李的版本，在训练过程中使用了大量人类棋手的棋谱。2017年10月19日，DeepMind公司在《自然》杂志发布了一篇新的论文，AlphaGo Zero——它完全不依赖人类棋手的经验，经过3天的训练，Alpha Go Zero击败了Master版本。AlphaGo Zero最重要的价值在于，它不仅仅可以解决围棋问题，它可以在不需要知识预设的情况下，解决一切棋类问题，经过几个小时的训练，已击败最强国际象棋冠军程序Stockfish。其应用场景非常广泛。</p><p>AlphaGo Zero 采用了蒙特卡洛树搜索＋深度学习算法，本文将尽可能用简单易懂的语言解释其工作原理。</p><h2 id="树搜索"><a href="#树搜索" class="headerlink" title="树搜索"></a>树搜索</h2><p><img src="http://upload-images.jianshu.io/upload_images/31319-b9de3b3bde6ac1c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="treesearch"></p><p>从一个棋盘的初始状态，开始思考下一步如何走。我们可以回顾一下我们思考的过程，我们会思考自己可以有哪几种走法，如果我走了这里，对手可能会走哪里，那么我还可以在哪里走。我和对手都会选择最有利的走法，最终价值最大的那一手，就是我要选择的下法。很明显这个思维过程是一颗树，为了寻找最佳的行棋点的过程，就是树搜索。</p><p>围棋第一手有361种下法，第二手有360种，第三手有359，依次类推，即一共有 361! 种下法，考虑到存在大量不合规则的棋子分布，合理的棋局约占这个数字的1.2%(<a href="https://link.zhihu.com/?target=https%3A//tromp.github.io/go/legal.html">Counting Legal Positions in Go</a>). 约为2.081681994 * 10^170。这个一个天文数字，比目前可观测宇宙的所有原子数还要多。要进行完全树搜索，是不可能的。因此我们必须进行剪枝，并限制思考的深度。所谓剪枝，就是指没必要考虑每种下法，我们只需考虑最有价值的几手下法。所谓限制思考的深度，就是我们最多只思考5步，10步，20步。常见的算法是Alpha-beta剪枝算法。但是，剪枝算法也有它的缺陷，它很有可能过早的剪掉了后期价值很大走法。</p><h2 id="蒙特卡洛方法"><a href="#蒙特卡洛方法" class="headerlink" title="蒙特卡洛方法"></a>蒙特卡洛方法</h2><p>简而言之，蒙特卡洛方法(Monte Carlo method)，是一种“统计模拟方法”。20世纪40年代，为建造核武器，冯.诺伊曼 等人发明了该算法。因赌城蒙特卡洛而得名，暗示其以概率作为算法的基础。</p><p>假设我们要计算一个不规则形状的面积，我们只需在包含这个不规则形状的矩形内，随机的掷出一个点，每掷出一个点，则N+1，如果这个点在不规则图形内则W+1。落入不规则图形的概率即为 W/N。当掷出足够多的点之后，我们可以认为：不规则图形面积＝矩形面积＊W/N。</p><p>要应用蒙特卡洛算法的问题，首先要将问题转化为概率问题，然后通过统计方法将其问题的解估计出来。</p><h2 id="蒙特卡洛树搜索（MCTS）"><a href="#蒙特卡洛树搜索（MCTS）" class="headerlink" title="蒙特卡洛树搜索（MCTS）"></a>蒙特卡洛树搜索（MCTS）</h2><p>1987年Bruce Abramson在他的博士论文中提出了基于蒙特卡洛方法的树搜索这一想法。这种算法简而言之是用蒙特卡洛方法估算每一种走法的胜率。如果描述的再具体一些，通过不断的模拟每一种走法，直至终局，该走法的模拟总次数N，与胜局次数W，即可推算出该走法的胜率为 W/N。</p><p>该算法的每个循环包含4个步骤：选择、扩展、仿真、反向传播。一图胜千言。</p><p><img src="http://upload-images.jianshu.io/upload_images/31319-08a2e9e9174b591f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MCTS"></p><p>图中N表示总模拟次数，W表示胜局次数。每次都选择胜率最大的节点进行模拟。但是这样会导致新节点无法被探索到。为了在最大胜率和新节点探索上保持平衡，UCT（Upper Confidence Bound，上限置信区间算法）被引入。所谓置信区间，就是概率计算结果的可信度。打个比方，如果掷了3次硬币，都是正面朝上，我们就认为掷硬币正面朝上概率是100%，那肯定是错误的，因为我们的样本太少了。所以UCT就是用来修正这个样本太少的问题。具体公式如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/31319-dbbfb7db809a4111.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UCT公式"></p><p>其中wi 是i节点的胜利次数，ni是i节点的模拟次数，Ni是所有模拟次数，c是探索常数，理论值为 √2，可根据经验调整。公式的后半部分，探索次数越少，值会越大，所以，那些被探索比较少的点，会获得更多的探索机会。</p><p>蒙特卡洛树搜索算法因为是直接模拟到游戏终局，所以这种算法更加的准确，而且并不需要一个明确的“估值函数”，你只需要实现游戏机制就足够了。而且，蒙特卡洛算法，可以随时终止，根据其训练的时间给予近似的最优结果。</p><p>但是对于围棋这种游戏而言，它的选择点依然太多，这棵树会非常的大。可能有一个分支早已被丢弃，那么它将不会被统计，这可能是李世石能够在第四局击败AlphaGo的主要原因。对于这类情况，我们依然需要依赖一个好的估值函数来辅助。</p><h2 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h2><p>近年来，深度卷积神经网络在视觉领域取得很大的成功，如图片分类，人脸识别等。深度学习的网络结构在此不赘述，简而言之，深度学习是一个最优化算法。</p><p>我们可以将深度神经网络理解为一个黑盒，这个黑盒接收一批输入，得到一个输出，并根据输出计算出损失（误差），这个误差会反馈给黑盒，当给了足够多的数据之后，这个黑盒将具备一个特性，就是使误差最小化。</p><p>如果这么说还是难以理解的话，可以打个比方：深度神经网络是一种生物，它喜欢吃糖，有学习的能力，你给它看一张图片，它告诉你是猫还是狗，如果它猜对了，你就给它一颗糖，猜错了，就不给糖，久而久之，它就有了分辨猫狗的能力。作为创造者，你甚至不知道它是如何分辨猫狗的，但是它做到了，看得越多，识别的就越准。</p><p>这里至关重要的是——输入是什么？输出是什么？什么时候给糖的动作，也就是损失函数如何设计？在实际的操作过程中，网络结构的设计也很重要，这里不再细述。</p><p>对于围棋来说，深度网络可以用来评估下一步的主要选点（降低树的宽度），以及评估当前局面的值。</p><h2 id="AlphaGo-Zero"><a href="#AlphaGo-Zero" class="headerlink" title="AlphaGo Zero"></a>AlphaGo Zero</h2><p>在AlphaGo Lee版本，有两个神经网络，一个是策略网络，是一个有监督学习，它利用了大量的人类高手的对弈棋局来评估下一步的可能性，另一个是价值网络，用来评价当前局面的评分。而在AlphaGo Zero版本，除了围棋规则外，没有任何背景知识，并且只使用一个神经网络。</p><p>这个神经网络以19x19棋盘为输入，以下一步各下法的概率以及胜率为输出，这个网络有多个batch normalization卷积层以及全连接层。</p><p>AlphaGo Zero的核心思想是：<em>MCTS算法生成的对弈可以作为神经网络的训练数据。</em> 还记得我们前面说过的深度学习最重要的部分吗？输入、输出、损失！随着MCTS的不断执行，下法概率及胜率会趋于稳定，而深度神经网络的输出也是下法概率和胜率，而两者之差即为损失。随着训练的不断进行，网络对于胜率的下法概率的估算将越来越准确。这意味着什么呢？这意味着，即便某个下法AGZ没有模拟过，但是通过神经网络依然可以达到蒙特卡洛的模拟效果！也就是说，我虽然没下过这手棋，但凭借我在神经网络中训练出的“棋感”，我可以估算出这么走的胜率是多少！</p><p>AlphaGo Zero的对弈过程只需应用深度网络计算出的下法概率、胜率、MCTS的置信区间等数据即可进行选点。</p><h2 id="AlphaGo-Zero-论文节选"><a href="#AlphaGo-Zero-论文节选" class="headerlink" title="AlphaGo Zero 论文节选"></a>AlphaGo Zero 论文节选</h2><p><img src="http://upload-images.jianshu.io/upload_images/31319-caf7b3f0dffdabac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AlphaGo Zero增强学习过程"></p><p>a:自我对弈过程s1，…，sT。 在每个状态st, 使用最近一次的网络fθ，执行一次MCTS αθ （见图2）。 下法根据MCTS计算的搜索概率而选择，at ~ πt. 评价终止状态sT，根据游戏规则来计算胜利者z。<br>b: AlphaGo Zero的神经网络训练。网络使用原始的棋盘状态st作为输入，通过数个卷积层，使用参数θ，输出有向量 pt, 表示下法的分布概率，以及一个标量vt，表示当前玩家在st的胜率。网络参数θ将自动更新，以最大化策略向量pt和搜索概率πt的相似性，并最小化预测赢家vt与实际赢家z的误差。新参数将应用于下一次自我对弈a的迭代。</p><p><img src="http://upload-images.jianshu.io/upload_images/31319-540aea408a78ee1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AlphaGo Zero 蒙特卡洛树搜索过程"></p><p>a: 每次模拟选择的分支，有最大Q+U, 其中Q是动作价值，U是上限置信，U依赖于一个存储在分支上的优先概率P和该分支的访问次数N（每访问一次N+1）。<br>b: 扩展叶节点，神经网络（P(s, .), V(s)) = fθ(s)评估s; 将向量P的值被存储在s的扩展边上。<br>c: 根据V更新动作价值（action-value)Q，反映所有该动作的子树的平均值。<br>d: 一旦搜索结束，搜索概率π被返回，与 Ν^(1/τ) 成正比，N是每个分支的访问次数，而τ是一个参数控制着温度（temperature）。</p><h2 id="AlphaGo-Zero的应用"><a href="#AlphaGo-Zero的应用" class="headerlink" title="AlphaGo Zero的应用"></a>AlphaGo Zero的应用</h2><p>AGZ算法本质上是一个最优化搜索算法，对于所有开放信息的离散的最优化问题，只要我们可以写出完美的模拟器，就可以应用AGZ算法。所谓开放信息，就像围棋象棋，斗地主不是开放信息，德扑虽然不是开放信息，但本身主要是概率问题，也可以应用。所谓离散问题，下法是一步一步的，变量是一格一格，可以有限枚举的，比如围棋361个点是可以枚举的，而股票、无人驾驶、星际争霸，则不是这类问题。Deepmind要攻克的下一个目标是星际争霸，因为它是不完全信息，连续性操作，没有完美模拟器（随机性），目前在这方面AI还是被人类完虐</p><p>所以看到AG打败人类，AGZ打败AG，就认为人工智能要打败人类了，这种观点在未来可能成立，但目前还有点危言耸听。距离真正打败人类，AGZ还差得很远。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文写于2017年12月，获&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32952677&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Udacity专栏转载&lt;/a&gt;。今将其搬运至我的博客。&lt;/p&gt;
&lt;p&gt;2016年3月，A
      
    
    </summary>
    
    
      <category term="AI" scheme="http://guileen.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>Promise模式在防止缓存雪崩中的应用</title>
    <link href="http://guileen.github.io/2019/11/01/promise-in-cache-crash/"/>
    <id>http://guileen.github.io/2019/11/01/promise-in-cache-crash/</id>
    <published>2019-10-31T16:00:00.000Z</published>
    <updated>2019-12-24T11:10:36.913Z</updated>
    
    <content type="html"><![CDATA[<p>对大多数高并发架构而言，缓存是不可或缺的。在数据持久化层，其核心是保证数据一致性，而吞吐能力往往较弱。而在缓存层，因其逻辑简单，则具备较高的吞吐能力，但为了保证数据的时效性，则必须设置缓存的过期时间。在缓存过期后，程序会从持久化层读取数据，填充缓存。我们通常称这种缓存加载方式为懒加载（lazy load）。</p><p>在缓存失效的瞬间，如果突然爆发大量缓存请求，则会导致所有请求穿透至持久化层，给持久化层带来巨大压力，这种现象叫做缓存雪崩。</p><p><img src="http://upload-images.jianshu.io/upload_images/31319-843693e8c36814b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="缓存雪崩"></p><h2 id="解决缓存雪崩的几种方案"><a href="#解决缓存雪崩的几种方案" class="headerlink" title="解决缓存雪崩的几种方案"></a>解决缓存雪崩的几种方案</h2><ol><li>在预加载时设置锁状态。后至的缓存请求，将获得锁状态，在一段时间后重试加载缓存。但这一方法不能保证第一时间返回数据。</li></ol><p><img src="http://upload-images.jianshu.io/upload_images/31319-5138b17e9260eacb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="穿透锁"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def lazyload(key):</span><br><span class="line">    value &#x3D; cache.get(key)</span><br><span class="line">    if(!value):</span><br><span class="line">        cache.set(key, &#39;__lock__&#39;)</span><br><span class="line">        value &#x3D; db.get(key)</span><br><span class="line">        cache.set(key, value)</span><br><span class="line">    if(value &#x3D;&#x3D; &#39;__lock__&#39;):</span><br><span class="line">        sleep(100)</span><br><span class="line">        return lazyload(key)</span><br><span class="line">    return value</span><br></pre></td></tr></table></figure><ol start="2"><li>这里重点介绍的Promise解决缓存穿透的思路，这种方法将使同一进程内对同一缓存的访问进行汇总，不仅减少对持久层的缓存穿透，而且也可以降低对缓存层的请求量。拥有极强的汇聚效果。</li></ol><p><img src="http://upload-images.jianshu.io/upload_images/31319-1443709321ad539e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Promise解决缓存雪崩"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def _lazyload(key):</span><br><span class="line">    value &#x3D; cache.get(key)</span><br><span class="line">    if(!value):</span><br><span class="line">        value &#x3D; db.get(key)</span><br><span class="line">        cache.set(key, value)</span><br><span class="line"></span><br><span class="line">promiseMap &#x3D; &#123;&#125;</span><br><span class="line">def lazyload(key):</span><br><span class="line">    def clearPromiseMap:</span><br><span class="line">        delete promiseMap[key]</span><br><span class="line">    promise &#x3D; promiseMap[key]</span><br><span class="line">    if(!promise):</span><br><span class="line">        promise &#x3D; Promise(_lazyload, key)</span><br><span class="line">        promise.then(clearPromiseMap)</span><br><span class="line">        promiseMap[key] &#x3D; promise</span><br><span class="line">    return promise.resolve()</span><br></pre></td></tr></table></figure><p>本文所有代码为伪代码！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对大多数高并发架构而言，缓存是不可或缺的。在数据持久化层，其核心是保证数据一致性，而吞吐能力往往较弱。而在缓存层，因其逻辑简单，则具备较高的吞吐能力，但为了保证数据的时效性，则必须设置缓存的过期时间。在缓存过期后，程序会从持久化层读取数据，填充缓存。我们通常称这种缓存加载方
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用docker-compose设置Gogs</title>
    <link href="http://guileen.github.io/2019/03/29/setup-gogs-with-docker-compose/"/>
    <id>http://guileen.github.io/2019/03/29/setup-gogs-with-docker-compose/</id>
    <published>2019-03-29T08:58:02.000Z</published>
    <updated>2019-12-21T06:04:23.595Z</updated>
    
    <content type="html"><![CDATA[<p>创建 ~/gogs/docker-compose.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">version: &#39;2&#39;</span><br><span class="line">services:</span><br><span class="line">  gogs:</span><br><span class="line">    container_name: gogs</span><br><span class="line">    image: gogs&#x2F;gogs</span><br><span class="line">    volumes:</span><br><span class="line">      - &#x2F;data&#x2F;gogs&#x2F;:&#x2F;data</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;3080:3000&quot;</span><br><span class="line">      - &quot;3022:22&quot;</span><br><span class="line">    restart: always</span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker-compose up -d</span><br></pre></td></tr></table></figure><p>Nginx配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name git.example.com;</span><br><span class="line"></span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;127.0.0.1:3080;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置注意事项：</p><ul><li><em>SSH Port:</em> Use the exposed port from Docker container. For example, your SSH server listens on 22 inside Docker, but you expose it by 10022:22, then use 10022 for this value. Builtin SSH server is not recommended inside Docker Container</li><li><em>HTTP Port:</em> Use port you want Gogs to listen on inside Docker container. For example, your Gogs listens on 3000 inside Docker, and you expose it by 10080:3000, but you still use 3000 for this value.</li><li><em>Application URL:</em> Use combination of Domain and exposed HTTP Port values (e.g. <a href="http://192.168.99.100:10080/" target="_blank" rel="noopener">http://192.168.99.100:10080/</a>).</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;创建 ~/gogs/docker-compose.yml&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>How ssl works and Letscrypt</title>
    <link href="http://guileen.github.io/2019/01/30/How-ssl-works-and-letscrypt/"/>
    <id>http://guileen.github.io/2019/01/30/How-ssl-works-and-letscrypt/</id>
    <published>2019-01-30T12:49:39.000Z</published>
    <updated>2019-12-21T06:04:23.595Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SSL-TLS-解决了什么问题？"><a href="#SSL-TLS-解决了什么问题？" class="headerlink" title="SSL/TLS 解决了什么问题？"></a>SSL/TLS 解决了什么问题？</h2><p>假设A给B发信息，直接明文发送，那么所有的中间传输节点，都可以截获明文，这种通信是不安全的，想象一下你的密码全部在网上明文传输，是不是很危险。</p><p>现在A将信息加密后传输给B，B解密信息，加密密钥和解密密钥是相同，这种加密算法叫做对称加密算法。题是，A如何把密钥告诉B？如果依然通过同一个中间人告诉B，一旦中间人知道这个密钥，那么传输过程就依然是不安全的了。</p><p>这时非对称加密算法出现了，非对称加密的加密解密需要两把钥匙，我们称之为公钥和私钥，所谓公钥就是可以公开的钥匙，可以安全的分享出去。使用公钥加密的数据必须用私钥解密，使用私钥加密的必须用公钥解密。如果A和B之间进行通信，那么AB双方首先交换各自的公钥，保留各自的私钥，这个过程是安全的。A要给B发信息则使用B的公钥加密，因为只有B自己拥有私钥，所以只有B可以解密信息，反之依然。这是非对称加密的第一个用途，防止中间人破译信息。非对称加密还有另一个用途————身份验证，如果A要向B表明身份证明自己的确是A，只需要按照B的要求加密一段随机字符串S即可，A使用自己的私钥加密S，将加密结果发送给B，B使用A提供的公钥进行解密，若结果为S，则证明对方的身份的确是A，这样就完成了认证过程，我们常用的ssh公钥登录，就是这个原理。</p><p>一切看起来很完美，但是还有一个问题没有解决。假设A、B之间有一个中间人C，AB之间的所有消息都经过C传递。这是C在这个传输过程做了手脚，当AB交换公钥时，A把公钥发给C，希望C把A的公钥转交给B，可是这是C没有把A的公钥交给B，而是把C的公钥交给了B，B误以为C的公钥就是A的公钥。在B把公钥发给A的过程中，C做了同样的手脚。这时A、B手上都是C的公钥，而C手上也有A、B的公钥。这时A给B发消息时，会使用C的公钥加密，C则先用C的私钥解密得出原文完成信息窃取，再用B的公钥加密信息发给B。AB都认为自己进行了安全的传输，一切天衣无缝。更可怕的是C还可以直接篡改信息。谁有能力做这件事？你的网络提供商，你连接的免费wifi，网络上的交换节点，都有能力实施这个中间人攻击。那么问题来了，既然交换公钥这种非对称加密手段都无法奏效，还搞毛线呢？这时就需要CA上场了。</p><pre><code>A  ---- A的公钥 ---&gt;  C  ---- C的公钥 ---&gt; BA  &lt;--- C的公钥 ----  C  &lt;--- B的公钥 ---- BA  --C公钥加密信息--&gt;  C  -- B公钥加密信息--&gt; BA  &lt;-C公钥加密信息---  C  &lt;- A公钥加密信息--- B</code></pre><p>CA的全称是Certificate Authority，即证书颁发机构。A为了保证自己的公钥不被中间人篡改，会先将自己的公钥交给CA，CA用自己的私钥教秘A的公钥，B使用CA的公钥解密A的公钥，只要CA的签名的公钥没有问题，则A的公钥也必然没有问题。那么又有一个新的问题来了，如果中间人C伪造CA的公钥怎么办？这个问题的解决方案比较粗暴，CA的公钥是直接写在浏览器里的。如果CA的公钥被篡改，浏览器会直接提示不安全的网络连接。因此我们也需要警惕一些山寨浏览器，如果没有道德底线的约束，他们完全可以篡改CA证书，为网络监听大开方便之门。</p><p>因为CA需要各大浏览器厂商的共同认可，因此是个壁垒很高的生意。如果一个网站需要提供安全的网络连接，则需要将自己的网站公钥通过CA生成一个认证公钥，这个认证的公钥也就是证书，这个证书不便宜。想象一下，每一年你都需要付出两千块钱，就是为了证明你是你，这钱花的是不是挺冤枉。你说我的网站就不提供安全传输不就完了吗，反正我这信息也都是公开的，也没什么值得监听的。不行，因为很多业务场景，第三方接口，必须要求你提供安全的网络连接。这就增加了开设一个网络服务的成本，尤其是增加了玩票的成本，小微创新就会受影响。</p><p><img src="/img/https_flowchart.jpg" alt=""></p><p>现在就该今天的主角上场了，<a href="https://letsencrypt.org/" target="_blank" rel="noopener">Letsencrypt</a>，他是一个免费、自动化的证书颁发机构。今天就向大家安利一下Letsencrypt。 Letsencryt在web server上运行了一个证书管理代理（Certificate management agent）的程序。假设我们希望设置<code>https://example.com</code>的证书。那么一共有两个步骤，第一步，证明你拥有exmaple.com，第二步，代理程序可以请求（request）、更新（renew）以及废除（revoke）证书，</p><p>Letsencrypt根据agent公钥来验证账号，agent第一次与Letsencrypt交互时，Letsencrypt会要求agent证明自己拥有某个域名。agent会询问需要自己做什么来证明自己拥有这个域名，这时Letsencrypt会下发一组任务，比如添加某个DNS记录，在网站下提供某个制定的资源。这和传统的CA证书机构类似。当agent完成操作后，CA就认为该agent已经拥有这个域名了，之后的域名更新都可以通过agent操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository ppa:certbot&#x2F;certbot</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install certbot</span><br><span class="line">$ sudo certbot certonly -d ipub.io -d *.ipub.io --manual --preferred-challenges dns --server https:&#x2F;&#x2F;acme-v02.api.letsencrypt.org&#x2F;directory</span><br></pre></td></tr></table></figure><p>跟着提示填写，其中一步要求在DNS记录中添加一个TXT，修改后继续，准确无误的话，证书会在/etc/letsencrypt/live/ipub.io/ 目录下, 修改nginx配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 443 ssl;</span><br><span class="line">  listen [::]:443 ssl;</span><br><span class="line">  keepalive_timeout 70;</span><br><span class="line"></span><br><span class="line">  root &#x2F;var&#x2F;www&#x2F;leen.ipub.io;</span><br><span class="line">  index index.html index.htm;</span><br><span class="line">  server_name leen.ipub.io;</span><br><span class="line">  ssl_certificate  &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;ipub.io&#x2F;fullchain.pem;</span><br><span class="line">  ssl_certificate_key  &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;ipub.io&#x2F;privkey.pem;</span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    try_files $uri $uri&#x2F; &#x2F;index.html &#x3D;404;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SSL-TLS-解决了什么问题？&quot;&gt;&lt;a href=&quot;#SSL-TLS-解决了什么问题？&quot; class=&quot;headerlink&quot; title=&quot;SSL/TLS 解决了什么问题？&quot;&gt;&lt;/a&gt;SSL/TLS 解决了什么问题？&lt;/h2&gt;&lt;p&gt;假设A给B发信息，直接明文发
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设置邮箱服务器</title>
    <link href="http://guileen.github.io/2019/01/29/set-up-a-mail-server/"/>
    <id>http://guileen.github.io/2019/01/29/set-up-a-mail-server/</id>
    <published>2019-01-29T14:40:54.000Z</published>
    <updated>2019-12-21T06:04:23.595Z</updated>
    
    <content type="html"><![CDATA[<p>发现自己已经有足足一年多没有更新任何博客了。过去的一年中，自己越来越多的在做管理型的工作，远离了一线开发，开发笔记类的东西也就少了。</p><p>最近这段时间一直在整理自己的思路，希望能够做些能够触达用户的事情，比如搞一个公众号之类的。而各种自媒体号都需要邮箱，申请免费邮箱又是很麻烦的事，搞不好密码忘了，也很麻烦。既然自己有域名，为什么不自己搞一个企业邮箱呢。常用的是腾讯的免费企业邮箱，但是只能绑定一个域名，而我的账号下已经绑定了一个域名。于是想着自己动手搭建一个邮箱服务器。</p><p>这个邮箱服务器的主要目标是接收各种注册邮件、验证码，并不要求完善的账号管理系统。备选方案有：</p><ol><li><a href="https://postal.atech.media/" target="_blank" rel="noopener">Postal</a>, write with ruby, MySQL</li><li><a href="https://modoboa.org/en/" target="_blank" rel="noopener">Modoboa</a>, write with python.</li><li>postfix</li><li>dovecot</li><li><a href="https://github.com/mailhog/MailHog" target="_blank" rel="noopener">MailHog</a></li><li><a href="https://github.com/toorop/tmail" target="_blank" rel="noopener">tmail</a></li><li><a href="https://mailinabox.email/" target="_blank" rel="noopener">Mail in a box</a></li><li><a href="https://github.com/djfarrelly/MailDev" target="_blank" rel="noopener">MailDev</a></li><li><a href="https://www.inbucket.org/" target="_blank" rel="noopener">Inbucket</a></li></ol><p>最终选择了maildev，安装简单方便</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i -g maildev</span><br><span class="line">maildev --web-user xx --web-pass xx</span><br></pre></td></tr></table></figure><p>使用supervisor，后台运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># supervisor&#x2F;conf.d&#x2F;maildev.conf</span><br><span class="line">[program:maildev]</span><br><span class="line">command&#x3D;&#x2F;opt&#x2F;nodejs&#x2F;bin&#x2F;maildev --web-user&#x3D;xx --web-pass&#x3D;xx -s 25 -w 1080</span><br><span class="line">redirect_stderr&#x3D;true</span><br><span class="line">stdout_logfile&#x3D;&#x2F;var&#x2F;log&#x2F;maildev.log</span><br><span class="line">stdout_logfile_maxbytes&#x3D;10MB</span><br><span class="line">stdout_logfile_backups&#x3D;10</span><br><span class="line">stdout_capture_maxbytes&#x3D;100MB</span><br></pre></td></tr></table></figure><p>修改DNS，添加MX记录为服务器IP。发邮件到<a href="mailto:test@example.com">test@example.com</a> 测试，打开 <code>http://example.com:1080/</code> ，可以看到自己刚发的邮件。说明已经可以有任意多的邮箱了。</p><p>把他和brook科学上网服务放在同一台服务器上，充分利用资源。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;发现自己已经有足足一年多没有更新任何博客了。过去的一年中，自己越来越多的在做管理型的工作，远离了一线开发，开发笔记类的东西也就少了。&lt;/p&gt;
&lt;p&gt;最近这段时间一直在整理自己的思路，希望能够做些能够触达用户的事情，比如搞一个公众号之类的。而各种自媒体号都需要邮箱，申请免费邮
      
    
    </summary>
    
    
      <category term="ops" scheme="http://guileen.github.io/tags/ops/"/>
    
  </entry>
  
  <entry>
    <title>backslash r</title>
    <link href="http://guileen.github.io/2017/06/06/backslash-r/"/>
    <id>http://guileen.github.io/2017/06/06/backslash-r/</id>
    <published>2017-06-06T09:28:04.000Z</published>
    <updated>2019-12-21T06:04:23.595Z</updated>
    
    <content type="html"><![CDATA[<p>一直都知道Windows底下的换行符是 <code>\r\n</code>，Linux系统下是<code>\n</code>。<br>但并没有关心过 <code>\r</code>和<code>\n</code> 到底是什么意思。其实 <code>\r</code> 是将光标移至行首，而 <code>\n</code> 是将光标移至下一行。这么一看也理解了为什么Windows会将换行符设置为<code>\r\n</code>了。</p><p>下面这段代码，可以看出<code>\r</code>的作用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var i &#x3D; 0</span><br><span class="line">function update() &#123;</span><br><span class="line">  i++</span><br><span class="line">  process.stdout.write(&quot;\r&quot; + i)</span><br><span class="line">  if ((i % 10) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">    console.log(&quot;&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(update, 100)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直都知道Windows底下的换行符是 &lt;code&gt;\r\n&lt;/code&gt;，Linux系统下是&lt;code&gt;\n&lt;/code&gt;。&lt;br&gt;但并没有关心过 &lt;code&gt;\r&lt;/code&gt;和&lt;code&gt;\n&lt;/code&gt; 到底是什么意思。其实 &lt;code&gt;\r&lt;/code&gt; 是将光
      
    
    </summary>
    
    
      <category term="cli" scheme="http://guileen.github.io/tags/cli/"/>
    
  </entry>
  
  <entry>
    <title>我在热拉工作的体验</title>
    <link href="http://guileen.github.io/2017/04/13/introduce-rela-tech-team/"/>
    <id>http://guileen.github.io/2017/04/13/introduce-rela-tech-team/</id>
    <published>2017-04-13T02:04:35.000Z</published>
    <updated>2019-12-21T06:04:23.595Z</updated>
    
    <content type="html"><![CDATA[<p>两年前我以CTO身份加入了一家专注于拉拉社交的互联网公司——热拉。有次和一个身在国外的朋友提起我正在做LGBT，他的第一反应是，wow！so cool！要知道，在硅谷，库克等一帮大佬都是弯的，数据显示硅谷有三分之一公司的中高层都是同性恋。所以在他人眼中，从事LGBT是一件很fasion的事业。配合我不羁的长发和稀虚的胡渣，很多人认为我也是弯的。很遗憾，我是一个直男癌晚期！</p><p>在很多人的看来，一个小众社交软件应该是很简单的，做好它应该不难。起初我也认为自己可以驾轻就熟的做好这件事，并且不需要多少的人手，但我很快意识到没那么简单。在我加入之时，热拉已经是上线了一年多，拥有完整的产品形态，几十万体量的用户。所有后端由java开发，每天到了晚高峰时间，服务器都会崩溃。而与此同时，我们的市场推广依然不能停下，产品迭代仍要进行，这对于技术架构改进来说，无疑是雪上加霜。</p><p>我提出了招聘更多的人员，拆分为两个后端团队的想法，一个团队进行产品架构的重构，而另一团队则对现有系统进行维护和改进，在重构完成后切换到新系统上。这个方案很快被否定了，相反，我们需要对团队进行压缩，因为我们当时正面临着财务的压力。原本人员就严重不足的后端团队，减少了一位java工程师，和运维工程师。<br>我们当时无暇去做架构上的调整，并不是我们不明白它的重要性，而是情势使然。我们只能从运维的角度来进行优化，将现有系统看作一个黑盒的系统，从各项指标来分析整个系统的瓶颈所在，按影响程度从高到低进行优化。至少，在晚高峰的时候服务器不再频繁的崩溃了。</p><p>为了在进行现有系统优化的同时，依然能满足产品迭代的需求，我尽可能的不增加现有后台的负担，使用node.js 提供完全独立于现有系统的一部分新API接口。选择node.js是因为他的开发效率高，也可以保证与现有系统完全解耦。</p><p>在这样的团队结构下，服务逐步得到了稳定，产品也在不断迭代中。虽然过程中我们依然遇到了各种各样的问题，但我们也度过了最困难的时期，成功融资，并且拥有了变现能力，现在的财务状况非常之好。</p><h3 id="热拉何时开始引入Go语言的？"><a href="#热拉何时开始引入Go语言的？" class="headerlink" title="热拉何时开始引入Go语言的？"></a>热拉何时开始引入Go语言的？</h3><p>在技术选型上编程语言的选型是基础，每种编程语言都有不同的特性，开源社区或是某家大公司支持都会影响它的生态。Java整个生态并不符合我们的“审美”。而且既有的java服务很不稳定，所以我们一直有计划替换掉java。</p><p>我们原本考虑使用node.js作为后端主要开发语言，但是我们在人才招聘上遇到了障碍，原因在于node.js工程师的后端能力可以说是良莠不齐。在意识到这一点后，我们决定使用Golang作为后端主要开发语言，而node.js主要应用于web相关的项目中。golang程序员相对而言，编程基础更加扎实，对后端的sense更好。</p><p>我们首次尝试Golang，是在聊天系统（IM）中。热拉的IM系统此前是使用的是XMPP协议的开源框架，当时已经达到了性能的瓶颈，难以维护和优化。因为IM系统是相对独立的，重写它对于整个系统架构没有太大影响，所以我决定自己使用Golang做一套IM系统。准确的说我们所开发的是一套网络通信框架，它包含Go服务端框架、Go客户端库、iOS客户端库、Android客户端库。我们的IM系统就是在这套网络通信框架之上开发的，目前已经在线上稳定运行一年多了。</p><p>另一个Golang的使用是重写整个后端API。当时我们的用户相比之前已经翻了几番，除了IM之外的功能主要还是在老后台上，在经历了几次严重的故障之后，我们终于决定使用Golang重写。我们的目标是灰度的、无缝的迁移，一切的重写对用户来说都是无感知的。所以Golang在热拉技术架构中的比重也越来越大了</p><h3 id="介绍一下技术团队"><a href="#介绍一下技术团队" class="headerlink" title="介绍一下技术团队"></a>介绍一下技术团队</h3><p>热拉这个产品除了在用户量级上比其他社交软件小以外，在产品功能上一点也不比其他社交软件少，甚至还要更多，更复杂。对比我们的团队规模，还是非常有挑战的，我们的原则是“小而美”。对于一名程序员来说，还有什么比做一件充满挑战的事情更有趣的呢？</p><p>我们下一步的计划是按照微服务架构对服务进行重构，这次是重构而不是重写。你可能会好奇，为什么不直接使用Golang重构，而是先重写，再重构？这一点说来话长，简言之是权衡风险与成本的结果。</p><p>我们认为每个微服务模块都应该有唯一的负责人，这可以让每一个团队成员都有自主发挥的空间。一部分的微服务也成为了我们实验新技术的环境，consul，NSQ等技术都有在应用。我们也会在接下来组建数据团队，在大数据架构中依然会选择Golang作为主要的语言，这与很多公司以java为主的做法是不一样的，但我们相信Golang是可以胜任大数据基础架构的工作的，并且可以让我们使用更少的人力资源和硬件资源来完成这件事。当然，这也是一个新的挑战。</p><p>所以我们也在 <strong>招聘更多优秀的Golang程序员</strong></p><ul><li>我们希望你首先对于Golang 语言特性的理解上是扎实的，同时也有3年以上的任意编程语言的后端开发经验</li><li>如果你完全没有Golang的经验，但是后端经验非常丰富，并乐于转型到Golang，我们也非常欢迎</li><li>如果你在github上有开源项目，在stackoverflow上有贡献答案，有坚持写博客的习惯，请把链接甩给我们</li><li>如果你有大数据相关经验那就更合适了</li><li>我们鼓励交流和分享，但不鼓励加班，我们认为加班与工作效率不存在正相关性</li><li>MBP是标配，也可以配备外置显示器</li></ul><p>如果你对我们有兴趣，请将你的简历直接发送至我的邮箱： ****@thel.co</p><p>—— Update 2019-01-29 ——</p><p>已于不久前离开该公司，我会带着感悟和收获继续前行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;两年前我以CTO身份加入了一家专注于拉拉社交的互联网公司——热拉。有次和一个身在国外的朋友提起我正在做LGBT，他的第一反应是，wow！so cool！要知道，在硅谷，库克等一帮大佬都是弯的，数据显示硅谷有三分之一公司的中高层都是同性恋。所以在他人眼中，从事LGBT是一件很
      
    
    </summary>
    
    
      <category term="gossip" scheme="http://guileen.github.io/tags/gossip/"/>
    
  </entry>
  
  <entry>
    <title>创作共用协议</title>
    <link href="http://guileen.github.io/2017/03/27/creative-commons-license/"/>
    <id>http://guileen.github.io/2017/03/27/creative-commons-license/</id>
    <published>2017-03-27T09:00:23.000Z</published>
    <updated>2019-12-21T06:04:23.595Z</updated>
    
    <content type="html"><![CDATA[<p>作为缺乏审美的工程师，当想要独立设计一些页面时，有时会感到力不从心。所幸的是如今是一个知识共享的时代，在码农的圈子里有开放源代码协议，在设计的圈子里也有创作共用协议即Creative Commons协议。</p><p>比如我们所熟知的bootstrap，其代码是使用MIT协议发布的，而其官网则是以Creative Commons协议发布的，意味着我们可以在CC协议之下使用其官网的设计。</p><p>有许多的设计开始通过Creative Commons协议发布，包括网页设计、字体、图标集等。</p><ul><li><a href="http://glyphicons.com/" target="_blank" rel="noopener">http://glyphicons.com/</a></li><li><a href="http://html5up.net" target="_blank" rel="noopener">http://html5up.net</a></li><li><a href="http://www.styleshout.com/" target="_blank" rel="noopener">http://www.styleshout.com/</a></li></ul><p>其他一些非CC协议的免费设计资源</p><ul><li>mononoki 字体</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为缺乏审美的工程师，当想要独立设计一些页面时，有时会感到力不从心。所幸的是如今是一个知识共享的时代，在码农的圈子里有开放源代码协议，在设计的圈子里也有创作共用协议即Creative Commons协议。&lt;/p&gt;
&lt;p&gt;比如我们所熟知的bootstrap，其代码是使用MIT
      
    
    </summary>
    
    
      <category term="resources" scheme="http://guileen.github.io/tags/resources/"/>
    
  </entry>
  
  <entry>
    <title>我今天都干了啥？</title>
    <link href="http://guileen.github.io/2017/03/08/one-day-of-my-life/"/>
    <id>http://guileen.github.io/2017/03/08/one-day-of-my-life/</id>
    <published>2017-03-08T10:09:02.000Z</published>
    <updated>2019-12-21T06:04:23.595Z</updated>
    
    <content type="html"><![CDATA[<p>我今天都干了啥</p><p>今天起了个大早，送娃上学，回来还早，玩了局王者，吃早饭，上班</p><p>打开电脑看了下TODO，邮箱、微信、QQ上的很多未读消息。</p><p>11点面试了一位产品经理，聊了她的工作经历，以及她对产品的理解，抛出了一些问题，没有什么问题，但也没有什么亮点打动我，还是淘汰了。</p><p>年后对接了很多三方服务，合同流程要走。两家文本识别服务，我们需要评估其质量，安排小伙伴将差异数据整理，并安排人工复审，统计各家质量，督促改进。</p><p>抽烟的时候，使用我们的app发了一个话题。</p><p>安排团建小分队的同学，确定技术分享会的最终流程，奖品，准备全员邮件，确认邮件内容。</p><p>准备新的JD，招人，也要看一下新的人才招聘渠道，与HR沟通。</p><p>叫外卖，吃午饭，今天没玩王者。休息一下，听公开课午睡。</p><p>某CDN的合作协议，来回多次，无法接受，对方的售前沟通能力实在够呛，也说明他们的服务的确一般，无奈国内网络环境就这样，而他们价格尚可接受，只得继续纠缠。</p><p>某些提现操作失败，需要退回金额，这个操作比较敏感，我一直是手动操作。决定安排小伙伴优化这段代码，完全自动化。</p><p>另一个必须手动操作的金额相关的调整。</p><p>某SEO合同寄到，签字盖章安排寄回，通知对方。</p><p>某直播服务合同确认，一些技术和计费细节还是要沟通清楚。我真的很努力的在为公司省钱啊。</p><p>某直播账单发票寄到，向财务请款，提醒相关人员审批。</p><p>某发邮件服务余额不足，前去支付并申请发票，以便以后报销。</p><p>还有一堆简历没有筛选，质量太差，懒得筛选。</p><p>开始写这个记录，回忆一下一天都干了什么。</p><p>开了一个10分钟的小会。</p><p>大部分的沟通都是需要往复的，所以以上很多事情都没有真正结束。我需要重新看一下TODO，整理一下思路。</p><p>已经周三了，本周计划还没提交，前去整理提交。</p><p>今天中途抽了几根烟，继续看那本关于人性的书。</p><p>产生了一个产品灵感，记录一下，年纪越大灵感越少，要珍惜。</p><p>已经17:30了，还有时间，要把简历都筛选掉。</p><p>感谢我的小伙伴们，没有什么事来打扰我，所以说团队搭建是CTO的首要工作。我也是心大，对他们的工作很放心，其实我最应该做的就是review一下他们的工作。说实话，我挺怀念不闻窗外事，只管写代码的日子，心静！那种不断的思考、设计、实现的过程，很爽。而现在不得不处理各种事情，没什么难度，但也不能假手于人。</p><p>可能是年初吧，各种外部的、产品的、团队的事情都挤在了一起，希望可以尽快了解掉一些事情，让自己可以更专注在某一方面。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我今天都干了啥&lt;/p&gt;
&lt;p&gt;今天起了个大早，送娃上学，回来还早，玩了局王者，吃早饭，上班&lt;/p&gt;
&lt;p&gt;打开电脑看了下TODO，邮箱、微信、QQ上的很多未读消息。&lt;/p&gt;
&lt;p&gt;11点面试了一位产品经理，聊了她的工作经历，以及她对产品的理解，抛出了一些问题，没有什么问题，
      
    
    </summary>
    
    
      <category term="gossip" scheme="http://guileen.github.io/tags/gossip/"/>
    
  </entry>
  
  <entry>
    <title>公共画像</title>
    <link href="http://guileen.github.io/2016/12/19/public-avatar/"/>
    <id>http://guileen.github.io/2016/12/19/public-avatar/</id>
    <published>2016-12-19T04:15:00.000Z</published>
    <updated>2019-12-21T06:04:23.594Z</updated>
    
    <content type="html"><![CDATA[<p>什么是SNS的本质？当我们看待一个SNS的时候，我们看到的是什么？</p><p>信息、状态、转发、私信、粉丝、评论，我们看到的是这些产品功能吗？还是这些数据？他的价值在哪里？</p><p>一个SNS，我们看到的是，我们自己的公共形象，或者是某些人的公共形象。SNS为这些红人提供了舞台。</p><p>而且，每个SNS所提供的舞台是不一样的，往来的红人也是不一样的。</p><p>SNS就像一个主题酒吧，来往形形色色的人，但他们身上或多或少会有一些共同点。在同一个SNS上，他们有同样的期许。</p><p>粉丝是一个两难的设计。没有粉丝，红人们没有动力在SNS上奋斗，而有了粉丝之后，任何的SNS最终会走向固化，红人霸占了主要的SNS资源。</p><p>这也是各种SNS会不断推陈出新的原因，因为有一批有潜质的红人，无论他／她是什么类别的红人，他需要一个舞台。但是有些场子，已经被人霸占，于是他们不得不寻找新的舞台。而总有一些SNS平台会抓住一些机会，提供某个类别的小舞台，这就是垂直SNS。</p><p>是否有可能干翻霸主级的社交网络？Facebook，twitter，国内的腾讯、微博。答案是能！本质上腾讯就被自己干翻了，微信取代QQ，本质上就是对霸主的挑战，虽然这一切发生在腾讯内部。但是微信取代QQ，这样的现象是难以复制的，为什么呢？因为微信取代QQ是发生在移动互联网与传统互联网更替的阶段的，是大事因缘，没有微信取代QQ，也会有其他应用取代QQ，但机会只有一次。</p><p>陌陌，用陌生人社交的方式占领了一定的市场，但是陌陌本身的名称定位已经把自己钉死了，就是陌生人社交。微信早期用摇一摇也达到了同样的爆发式增长，但用户规模上去之后，微信就可以弱化了这一个功能。</p><p>SNS下一个风口在哪里？SNS不是风口，但机会永远存在。挑战霸主级的社交网络，需要的是天时地利人和。产品与用户，双方共同成就了一个霸主级社交产品。得红人者得天下，微博的发展正是这样的模式。</p><p>但红人是本身就存在的，还是通过平台而红的，这个问题很关键。一个优秀的SNS平台应该有制造红人的能力，或者是让红人可以成长起来的能力。当你知道的红人越来越多的来自微信公众号，而不是来自微博的时候，那么说明微博的影响力降低了。</p><p>因此霸主级的似乎不可撼动的庞然大物其实是可以被打败的。</p><p>如何再造一个现象级的社交网络，我们不应该从产品模式上来思考这个问题，而是需要从人性的角度上来思考这个问题。人性是社交网络之所以成立的本质。更具体的说，人的社会性，情绪化，是社交网络的根本驱动力。人渴望被关注，渴望交流，渴望存在感，或只是渴望来自他人的声音。找到人在精神上的未被充分满足的需求点，强化这种概念，就有机会在社交产品中找到一席之地。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;什么是SNS的本质？当我们看待一个SNS的时候，我们看到的是什么？&lt;/p&gt;
&lt;p&gt;信息、状态、转发、私信、粉丝、评论，我们看到的是这些产品功能吗？还是这些数据？他的价值在哪里？&lt;/p&gt;
&lt;p&gt;一个SNS，我们看到的是，我们自己的公共形象，或者是某些人的公共形象。SNS为这些
      
    
    </summary>
    
    
      <category term="gossip" scheme="http://guileen.github.io/tags/gossip/"/>
    
  </entry>
  
  <entry>
    <title>Python数据分析笔记</title>
    <link href="http://guileen.github.io/2016/12/15/python-data-analysis-note/"/>
    <id>http://guileen.github.io/2016/12/15/python-data-analysis-note/</id>
    <published>2016-12-15T13:51:36.000Z</published>
    <updated>2019-12-21T06:04:23.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="可选"><a href="#可选" class="headerlink" title="[可选]"></a>[可选]</h1><p>install python</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pip install -U pip</span><br><span class="line"></span><br><span class="line">pip install &lt;something&gt;</span><br><span class="line">pip uninstall &lt;something&gt;</span><br></pre></td></tr></table></figure><p>pip support virtualenv</p><h1 id="Anaconda"><a href="#Anaconda" class="headerlink" title="[Anaconda]"></a>[Anaconda]</h1><p><a href="https://www.continuum.io/downloads" target="_blank" rel="noopener">Install anaconda</a></p><p>国内可从清华镜像下载，并设置镜像</p><p><a href="https://mirror.tuna.tsinghua.edu.cn/help/anaconda/" target="_blank" rel="noopener">清华镜像源</a></p><p>MacOS:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;archive&#x2F;Anaconda2-x.x.x-MacOSX-x86_64.sh&#96;</span><br><span class="line">bash Anaconda2-x.x.x-MacOS-x86_64.sh</span><br></pre></td></tr></table></figure><p>会安装到~/anaconda2下，默认会将PATH设置在 bash_profile中，根据你自己的shell设置，加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH&#x3D;&quot;&#x2F;home&#x2F;xx&#x2F;anaconda2&#x2F;bin:$PATH&quot;</span><br></pre></td></tr></table></figure><p>重新打开你的shell，执行<code>conda</code>命令测试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;free&#x2F;</span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure><p>Python环境管理:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create --name py27 python&#x3D;2.7</span><br><span class="line">activate py27</span><br></pre></td></tr></table></figure><p>包管理:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda list</span><br><span class="line">conda install numpy</span><br></pre></td></tr></table></figure><p>(conda install 会安装或更新依赖库，pip install则不会)</p><h1 id="安装工具包"><a href="#安装工具包" class="headerlink" title="[安装工具包]"></a>[安装工具包]</h1><p>conda install numpy scipy pandas matplotlib</p><h1 id="IDE"><a href="#IDE" class="headerlink" title="[IDE]"></a>[IDE]</h1><p>spyder, pycharm, sublime text, vim</p><h1 id="Jupyter"><a href="#Jupyter" class="headerlink" title="[Jupyter]"></a>[Jupyter]</h1><p><code>ipython</code> 一个更好的python交互命令</p><p><code>jupyter notebook</code> Web记事本，可以将交互过程记录并分享。</p><p>后续使用 jupyter 记录。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;可选&quot;&gt;&lt;a href=&quot;#可选&quot; class=&quot;headerlink&quot; title=&quot;[可选]&quot;&gt;&lt;/a&gt;[可选]&lt;/h1&gt;&lt;p&gt;install python&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td 
      
    
    </summary>
    
    
      <category term="machine-learning" scheme="http://guileen.github.io/tags/machine-learning/"/>
    
      <category term="python" scheme="http://guileen.github.io/tags/python/"/>
    
      <category term="data" scheme="http://guileen.github.io/tags/data/"/>
    
  </entry>
  
  <entry>
    <title>问题汇总</title>
    <link href="http://guileen.github.io/2016/11/24/architect-problems/"/>
    <id>http://guileen.github.io/2016/11/24/architect-problems/</id>
    <published>2016-11-24T06:55:49.000Z</published>
    <updated>2019-12-21T06:04:23.594Z</updated>
    
    <content type="html"><![CDATA[<p>负责某公司技术以来，遇到了一些问题，汇总一下：</p><ol><li>接口设计问题，错误的接口设计将导致难以避免的问题</li><li>DNS劫持问题，用户网络问题定位困难</li><li>苹果IAP漏单问题</li><li>缓存时间、状态不一致、压力太大、崩溃重启、启动慢问题</li><li>NoSQL选型问题</li><li>数据库负载问题，主从同步问题</li><li>日志监控问题</li><li>服务自动扩容，全球部署问题</li><li>垃圾信息、僵尸账号问题</li><li>IM丢消息，收不到消息问题。</li><li>IM、群聊问题定位、测试困难</li><li>聊天信息存储问题</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;负责某公司技术以来，遇到了一些问题，汇总一下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;接口设计问题，错误的接口设计将导致难以避免的问题&lt;/li&gt;
&lt;li&gt;DNS劫持问题，用户网络问题定位困难&lt;/li&gt;
&lt;li&gt;苹果IAP漏单问题&lt;/li&gt;
&lt;li&gt;缓存时间、状态不一致、压力太大、崩溃重
      
    
    </summary>
    
    
      <category term="ops" scheme="http://guileen.github.io/tags/ops/"/>
    
  </entry>
  
  <entry>
    <title>笔墨之殇</title>
    <link href="http://guileen.github.io/2016/11/24/bimozhishang/"/>
    <id>http://guileen.github.io/2016/11/24/bimozhishang/</id>
    <published>2016-11-23T16:16:01.000Z</published>
    <updated>2019-12-21T06:04:23.594Z</updated>
    
    <content type="html"><![CDATA[<p>说点什么好呢？这两天我开始，翻阅以前我读过的书，我发现，有很多的书，只是草草看过，还有一些书，根本没有看过。原来自己有做读书笔记的习惯，可是当我把阅读的时间放到地铁上之后，这个习惯，也随之消失了。以至于我根本不知道这本书，有没有读过。纸质书，可以有记录笔记的空间，而电子书，阅读起来比较方便，我想这就是纸质书和电子书的区别吧！</p><p>以前我总想写点文字。可是我发现自己，写作的速度越来越慢了，也找不到合适的输入法。拼音输入法，当你想打一些，书面语，或者是文言文的时候，就很难输入。而，五笔输入法或者其他的字型输入法，都有一个问题，就是，学起来太麻烦了，我根本记不住那些字码表，而且，当我，去回忆那些字码的时候，我的思路已经被打断了。</p><p>我还是喜欢拿着笔在纸上写字的感觉。在这种状态下，我的思路是最流畅的。</p><p>一直以来，我都想写一两本小说，可是构思了很久，却迟迟没有动笔。自己内心真正想表达的东西，和整个故事的结构，往往存在冲突。我不愿意写一些，没有人想看的东西，但我也不想，完全是为了迎合别人的口味，而写作。</p><p>其实，这并不是什么文章，我这是在测试一种新的输入法，一种，新的写作方式，那就是，直接把我想写的，念出来。你所看到的一切，都是我通过语音输入的。好吧，今天就说到这里，我的脚也泡好了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;说点什么好呢？这两天我开始，翻阅以前我读过的书，我发现，有很多的书，只是草草看过，还有一些书，根本没有看过。原来自己有做读书笔记的习惯，可是当我把阅读的时间放到地铁上之后，这个习惯，也随之消失了。以至于我根本不知道这本书，有没有读过。纸质书，可以有记录笔记的空间，而电子书，
      
    
    </summary>
    
    
      <category term="gossip" scheme="http://guileen.github.io/tags/gossip/"/>
    
  </entry>
  
  <entry>
    <title>如何学习编程</title>
    <link href="http://guileen.github.io/2016/11/21/how-to-learn-computer-sciense/"/>
    <id>http://guileen.github.io/2016/11/21/how-to-learn-computer-sciense/</id>
    <published>2016-11-21T06:35:31.000Z</published>
    <updated>2019-12-21T06:04:23.594Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编程入门"><a href="#编程入门" class="headerlink" title="编程入门"></a>编程入门</h2><p>大部分人都是通过某一个原因，喜欢上了编程。同样，你也需要一个理由。也许只是走在路上，忽然有人对你说：“年轻人，我看你天赋异禀，骨骼惊奇，我这里有一套编程秘笈，你想不想学啊”</p><p>入门编程语言，有很多选择，你可以选择python、JS，也可以选择C。比如我自己，是通过Basic语言入门的，也是因为它喜欢上了编程。</p><p>…</p><p>在这一阶段，最容易出现的问题是：Compiler Error，Syntax Error。你还不习惯和计算机进行沟通，你们之间的语言不够顺畅。它听不懂你说什么，当它说Error，你也听不懂它在说什么。你总是很抓狂的问，What’s the Error，一定是计算机出了什么问题，而不是我的代码有任何问题。直到你意识到，计算机没有任何问题，有问题的一定是我的代码，你能够检查你的代码，修复语法错误，恭喜你，你已经入门了。</p><p>这一阶段，你对编程有了感性的认识。你为自己写出来的东西感到骄傲，完全不会注意到其实那些代码其实只是piece of shit。你也会遇到很多的问题，即使你已经查阅到了所需要的知识点，还是无法实现你要的功能。就好像已经把所需要的材料全部交给了你，你却无法用这些材料造出你想造的东西。</p><p>这一段时间，你的灵感泉涌，有很多的想法想要去做，但却又感觉力不从心。你需要开始补充一些基础知识了，难度也要开始增加。</p><h2 id="计算机科学基础"><a href="#计算机科学基础" class="headerlink" title="计算机科学基础"></a>计算机科学基础</h2><p>这是一个非常重要的阶段，这一阶段的学习效果，直接决定了你的技术实力。有些知识，并不会立刻用得上，但是，这些知识，已经潜移默化的影响了你的思维方式。你的任督二脉将在这一阶段打开。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>算法和数据结构 这是一切程序的基础，你需要恰当的使用这些数据结构，你无法绕开它们。有一些算法，你需要知道它们的原理，这有助于你理解你的代码最终在计算机上是如何运行的。你可能并不需要掌握算法设计的机巧，也不需要去参加一个算法比赛。但你需要理解这些经典算法，记住它们的名字，在你遇到问题时，第一时间想到它们。最终，你可能不需要自己去实现它们，但你需要恰当的使用现有的算法代码。</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>函数式编程、面向对象编程，设计模式。这些方面的知识，你也需要掌握，你需要了解如何将自己的代码组织在一起。这就像你拥有了一些积木，你需要了解玩积木的常用技巧。阅读一些书籍或者阅读他人的代码，都是非常好的途径。学习这些知识，就像是学习作画。这些技巧你一看就会明白，但却不能熟练的使用。这里是考验你艺术天分的地方。</p><p>在拥有了以上这些技能后，你已经可以算是一个不错的程序员了。但这些知识可以让你写出很棒的代码，却无法使你的程序有任何的功能。你必须要让你的程序和外界进行交互，它才有存在的价值。</p><h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><p>你的程序如何和外界进行交互？你的程序是运行在一个封闭的环境之中的。想象一下，一只猴子被关进了一个房间中，房间中有一个操作面板，当它按下某个按钮，外界就会发生某件事情，比如说在你的电脑上打开一个新网页。你的程序就是这只猴子，你必须熟悉你的操作面板，有些时候面对一些奇怪的面板故障，你甚至需要了解它的工作原理，以避免发生那些故障。</p><p>网络基础, TCP/IP 协议，HTTP协议，如果你要开发网络应用，这些都是非常重要的基础知识。</p><p>操作系统原理，无论你开发桌面应用、移动应用、嵌入式应用、网络应用、服务器端应用，你都应该对你的程序所运行的环境有足够了解。</p><p>如果你开发的是Web应用，也许你不需要了解操作系统，但你需要了解你的浏览器，它是你的运行环境。</p><p>计算机架构，这个你可以不必知道。但如果你要开发一个操作系统，那么你必须对计算机架构有所了解，还是那句话，你需要了解你的程序所运行的环境。而操作系统所运行的环境就是计算机硬件的体系架构。</p><h2 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h2><p>你需要一个目标，你定下的这个目标可能就是下一个facebook。带着目标学习，这是我所推崇的方式。对于还处于学习阶段的你来说，这是一段幸福的时光。你不必为了生计而学习，你可以纯粹的为了爱好而学习。</p><p>你需要加入开发者交流的社区，加入论坛、QQ群、讨论组、邮件列表。与别人分享你的收获与挫折，社区的氛围也是你继续学习的动力之一。当你遇到难题，可以在社区里提问。但是你应该学习一些提问的智慧，不要做伸手党，这对你的学习不会有任何帮助。你应该至少已经阅读了相关的书籍、资料，并借助搜索引擎（不要使用baidu，中国可以用bing）来寻求答案。记住一点：社区不能给你想要的东西，但社区可以解答你的疑惑。社区是用来交流的，你也可以通过回答别人的问题来提高自己的知识。</p><p>开源社区，也是你获取知识技能的主要来源之一。当你需要某个功能，有人可能已经实现了他，并将他开源在了github（目前最大的开源社区）之类的地方。这些开源项目可以帮助你解决某些细节问题，使你可以更专注在你的主要目标上。对于优秀的开源项目，你可以阅读他们的代码，学习他们的机巧。</p><h2 id="再论运行环境"><a href="#再论运行环境" class="headerlink" title="再论运行环境"></a>再论运行环境</h2><p>如果你仔细体会的话，你会发现，编写代码只占到你学习编程中的很少的一部分时间，而大部分时间，你是在查阅资料。你需要花大量的时间在学习程序的运行环境上，而不是学习编程语言上。运行环境会提供给你很多的编程接口，一般被称之为API。</p><p>我这里所说的运行环境，并不是仅仅指操作系统运行环境，它也可以是浏览器，Java运行环境，Sevlet容器，node.js，unity3D运行环境，flash运行环境，directX，OpenGL，cocos2d游戏开发框架。</p><p>你可能注意到了一点，我将开发框架，视作了一种运行环境。为什么这么说呢？因为框架是对运行环境的再次封装，在框架之上，你将看到更加易用，更加人性化的接口。有一些框架，还额外提供了很多辅助的库，甚至插件机制，让你可以直接使用整个社区贡献的插件。你只需要面对框架编程，借来几个插件，再搭配几个辅助库，就可以完成一个作品。</p><p>你明白了吗？编程就是这么简单！这也是为什么有那么多平庸的程序员的主要原因————他们只懂得在框架之上编程，使用别人写好的现成的代码。<em>可是一旦他所赖以生存的框架或插件或库，出现了任何问题，他们的平庸就会显现</em>。</p><p>如果你是初次接触编程，还不知道什么是开发框架（framework）什么是库（library）的话，没关系，你只需要记住一点：Library决定了你能做什么，framework决定了你不能做什么。如果有一个新的框架，让你眼前一亮，蠢蠢欲动，请保持冷静，先想一想，如果你用了这个框架，你将失去哪些能力，是否是可以接受的？我看过太多的项目因为框架的限制，而不得不使用一些旁门左道来突破框架的限制，从而失去了代码的美感。抑或是自己动手，将框架改的面目全非，完全失去了框架的意义。</p><p>对于初学者，我强烈建议远离框架。框架是一种捷径，但对于一个以学习阶段的人来说，捷径是并不是什么好事。如果你已经有了足够的经验，对你的运行环境足够了解了之后，你应该在你的运行环境之上，寻找一个优秀的框架，学习它的设计思想。更进一步的，你可以搭建一个你自己的框架。我并不反对使用框架，但我反对不求甚解的使用框架。</p><p>修炼是一个长期的过程，即使你已经成为了一名优秀的程序员，你依然需要不断的修炼。记住一点：<em>修炼的捷径就是不走捷径</em>。</p><h2 id="Hack"><a href="#Hack" class="headerlink" title="Hack"></a>Hack</h2><p>你可能想要做一些看起来不可能的事情，这通常是从某个夸张的想法而引起的。Hook、反射，这些略有些高级的技巧。</p><h2 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h2><p>你已经找到了你的第一份工作，你加入了一个团队，经过一段时间，你又被提升为了项目组长。你需要开始考虑一些团队管理问题、系统架构问题</p><h2 id="专业方向"><a href="#专业方向" class="headerlink" title="专业方向"></a>专业方向</h2><h2 id="一些资源："><a href="#一些资源：" class="headerlink" title="一些资源："></a>一些资源：</h2><p><a href="https://pdos.csail.mit.edu/6.828/2014/" target="_blank" rel="noopener">MIT 6.828 操作系统工程</a><br><a href="github.com">github.com</a><br><a href="stackshare.io">stackshare.io</a><br><a href="stackoverflow.com">stackoverflow.com</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;编程入门&quot;&gt;&lt;a href=&quot;#编程入门&quot; class=&quot;headerlink&quot; title=&quot;编程入门&quot;&gt;&lt;/a&gt;编程入门&lt;/h2&gt;&lt;p&gt;大部分人都是通过某一个原因，喜欢上了编程。同样，你也需要一个理由。也许只是走在路上，忽然有人对你说：“年轻人，我看你天赋异禀
      
    
    </summary>
    
    
      <category term="education" scheme="http://guileen.github.io/tags/education/"/>
    
  </entry>
  
  <entry>
    <title>游戏开发书籍</title>
    <link href="http://guileen.github.io/2016/11/20/game-development-books/"/>
    <id>http://guileen.github.io/2016/11/20/game-development-books/</id>
    <published>2016-11-20T14:35:28.000Z</published>
    <updated>2019-12-21T06:04:23.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><p>(2015) Prototyping(21st Century Skills Innovation Library: Makers as Innovators)<br>(2015) Spelunky (Boss Fight Books #11)<br>(1988) The Design of Everyday Things<br>(2008) The Art of Game Design: A Book of Lenses</p><h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><p>(2001) Mathematics for 3D Game Programming and Computer Graphics<br>(2002) 3D Math Primer for Graphics and Game Development</p><h1 id="图形学"><a href="#图形学" class="headerlink" title="图形学"></a>图形学</h1><p>Computer Graphics: Principles and Practice<br>(1999) Real-Time Rendering<br>Physically Based Rendering: From Theory to Implementation</p><h1 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h1><p>Modern C++ Design: Generic Programming and Design Patterns Applied<br>More Effective C++<br>(1999) C++ Standard Library: A Tutorial and Reference</p><h1 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h1><p>(2009) Game Engine Architecture<br>(2011) Game Programming Patterns<br>(2003) Game Coding Complete<br>Game Physics Engine Development: How to Build a Robust Commercial-Grade Physics Engine for Your Game</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>(1st 2004) Real-Time Collision Detection (The Morgan Kaufmann Series in Interactive 3d Technology)<br>Game Programming Algorithms and Techniques: A Platform-Agnostic Approach</p><h1 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h1><p>Programming Game AI by Example<br>Artificial Intelligence for Games</p><h1 id="MMO"><a href="#MMO" class="headerlink" title="MMO"></a>MMO</h1><p>(2015) Multiplayer Game Programming: Architecting Networked Games (Game Design)</p><h1 id="Unity-不推荐"><a href="#Unity-不推荐" class="headerlink" title="Unity (不推荐)"></a>Unity (不推荐)</h1><p>Unity in Action</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设计&quot;&gt;&lt;a href=&quot;#设计&quot; class=&quot;headerlink&quot; title=&quot;设计&quot;&gt;&lt;/a&gt;设计&lt;/h1&gt;&lt;p&gt;(2015) Prototyping(21st Century Skills Innovation Library: Makers as I
      
    
    </summary>
    
    
      <category term="game-dev, books" scheme="http://guileen.github.io/tags/game-dev-books/"/>
    
  </entry>
  
  <entry>
    <title>Too many open files 的解决办法</title>
    <link href="http://guileen.github.io/2016/11/14/fix-too-many-open-files/"/>
    <id>http://guileen.github.io/2016/11/14/fix-too-many-open-files/</id>
    <published>2016-11-14T14:26:31.000Z</published>
    <updated>2019-12-21T06:04:23.593Z</updated>
    
    <content type="html"><![CDATA[<p>在开发TCP网络应用的过程中，我们经常会遇到“Too many open files”这个问题。这说明你的程序以达到Linux所允许的打开文件数上限。你需要按照以下方式来提升：</p><h3 id="每用户上限："><a href="#每用户上限：" class="headerlink" title="每用户上限："></a>每用户上限：</h3><p>打开 <code>/etc/security/limits.conf</code><br>在末尾添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*         hard    nofile      500000</span><br><span class="line">*         soft    nofile      500000</span><br><span class="line">root      hard    nofile      500000</span><br><span class="line">root      soft    nofile      500000</span><br></pre></td></tr></table></figure><p>修改后，你需要logout并重新login。</p><h4 id="pam-limits"><a href="#pam-limits" class="headerlink" title="pam-limits"></a>pam-limits</h4><p>据说对于Daemon进程需要额外的步骤，但目前我并不需要。如果以上改动不能对你有所帮助，可能需要以下步骤。</p><p>打开 <code>/etc/pam.d/common-session</code></p><p>添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session required pam_limits.so</span><br></pre></td></tr></table></figure><h3 id="系统级限制"><a href="#系统级限制" class="headerlink" title="系统级限制"></a>系统级限制</h3><p>这项设置应该大于没用户限制。</p><p>打开 <code>/etc/sysctl.conf</code></p><p>添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.file-max &#x3D; 2097152</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p>这会增加系统级的最大打开文件数。</p><h2 id="验证效果"><a href="#验证效果" class="headerlink" title="验证效果"></a>验证效果</h2><p>使用以下命令验证系统级最大打开文件数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max</span><br></pre></td></tr></table></figure><p>Hard Limit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -Hn</span><br></pre></td></tr></table></figure><p>Soft Limit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -Sn</span><br></pre></td></tr></table></figure><h3 id="检测用户限制"><a href="#检测用户限制" class="headerlink" title="检测用户限制"></a>检测用户限制</h3><p>将<code>www-data</code>替换为你希望检测的用户。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - www-data -c &#39;ulimit -aHS&#39; -s &#39;&#x2F;bin&#x2F;bash&#39;</span><br></pre></td></tr></table></figure><h3 id="检测运行中的进程限制"><a href="#检测运行中的进程限制" class="headerlink" title="检测运行中的进程限制"></a>检测运行中的进程限制</h3><p>将<code>XXX</code>替换为PID</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;XXX&#x2F;limits</span><br></pre></td></tr></table></figure><p>今日在一台新启动的服务器上，系统级、用户级配置都正常，唯独进程的limits仅为默认1024。进程使用的是supervisor守护启动，使用supervisor restart进程后，limits依然为1024，后重启了supervisor服务，limits恢复所设定数值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在开发TCP网络应用的过程中，我们经常会遇到“Too many open files”这个问题。这说明你的程序以达到Linux所允许的打开文件数上限。你需要按照以下方式来提升：&lt;/p&gt;
&lt;h3 id=&quot;每用户上限：&quot;&gt;&lt;a href=&quot;#每用户上限：&quot; class=&quot;hea
      
    
    </summary>
    
    
      <category term="ops" scheme="http://guileen.github.io/tags/ops/"/>
    
      <category term="network" scheme="http://guileen.github.io/tags/network/"/>
    
      <category term="tcp" scheme="http://guileen.github.io/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>开源静态网站生成工具</title>
    <link href="http://guileen.github.io/2016/11/08/static-site-generators/"/>
    <id>http://guileen.github.io/2016/11/08/static-site-generators/</id>
    <published>2016-11-07T16:00:00.000Z</published>
    <updated>2019-12-21T06:04:23.593Z</updated>
    
    <content type="html"><![CDATA[<p>有博客订阅者反馈我的博客ATOM输出有问题，总有两篇已unpublish的博客出来诈尸。这个是个老问题，当时也是因为总是有这两篇博客捣乱所以unpublish了，但完全无效。</p><p>自己的博客一直没有认真维护，只是偶尔随手记录，更没有想到有人订阅了，闻之顿感责任重大。计划认真整理一下自己的博客。</p><p>那两篇诈尸的博客，或是github的bug，或是jekyll的bug，未能验证。细思之，将博客系统完全交予github管理，的确不够合理，于是考虑使用本地生成静态文件再行push的方式，代替先push再由github jekyll生成静态文件的方式。顺便也更新一下自己博客的样式。</p><p>关于jekyll，也有不少问题，比如不能生存tag page等，也考虑更换一下生成器。奈何目前的静态网站生成器着实太多，无从选择。幸有有心人整理了一个列表，<a href="https://www.staticgen.com/" target="_blank" rel="noopener">staticgen.com</a>，包含了github的关注数、项目使用的语言，模版语言等信息，选择方便了许多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有博客订阅者反馈我的博客ATOM输出有问题，总有两篇已unpublish的博客出来诈尸。这个是个老问题，当时也是因为总是有这两篇博客捣乱所以unpublish了，但完全无效。&lt;/p&gt;
&lt;p&gt;自己的博客一直没有认真维护，只是偶尔随手记录，更没有想到有人订阅了，闻之顿感责任重大
      
    
    </summary>
    
    
      <category term="generator" scheme="http://guileen.github.io/tags/generator/"/>
    
  </entry>
  
  <entry>
    <title>计算机科学经典书籍</title>
    <link href="http://guileen.github.io/2016/10/17/classic-computer-sciense-books/"/>
    <id>http://guileen.github.io/2016/10/17/classic-computer-sciense-books/</id>
    <published>2016-10-16T16:00:00.000Z</published>
    <updated>2019-12-21T06:04:23.593Z</updated>
    
    <content type="html"><![CDATA[<p>在我学习编程的过程中，看过很多的书籍，大部分的书籍只能提供很有限的知识，有的甚至不能提供真正的“知识，充其量只是某个软件产品的使用手册而已，而且这类手册极易过时。现在，因为工作的需要，我依然会偶尔阅读这类“手册”。但我渐渐体会到了有些计算机知识是永恒的，如果从一开始我所阅读的，都是这些永恒的知识，而不是那些短暂的技能，我的知识体系会比现在更加的完整。</p><p>所以，我整理了这个列表。我希望他能涵盖目前已知的计算机科学体系，并且尽可能的在每个领域都提供一两本经典书籍。我会优先选取发布时间较早的书籍，因为那代表着它经得起时间的考验，同时我会参考Amazon和豆瓣的评分，以及维基百科等网站的引用和评价。我希望所提供的这个列表是“相对权威”的列表。</p><p>我会尽可能的包含中文译名和英文原版书名。</p><p>我会尽可能按照权威的学科分类对书籍进行划分，如果在分类上有错误，希望各位指出。</p><p>我也希望能够对学科间的依赖关系明确描述，默认是无依赖，当我发现了某个学科需要依赖于一些前置知识的时候，我会注明。如有遗漏，希望指出。</p><p>在列表中，也会包含部分非“计算机科学”方面的书籍，比如游戏开发，互联网相关的书籍。这些书籍入选的条件时，他是适合程序员阅读的，并且同样符合经典、权威的要求的。</p><h2 id="科普"><a href="#科普" class="headerlink" title="科普"></a>科普</h2><ul><li>1985 计算机科学概论 Computer Science: An Overview</li><li>1999 编码 Code</li></ul><h2 id="计算历史"><a href="#计算历史" class="headerlink" title="计算历史"></a>计算历史</h2><ul><li>The Computer from Pascal to von Neumann</li><li>A History of Computing in the Twentieth Century</li></ul><h2 id="Mathematics-数学"><a href="#Mathematics-数学" class="headerlink" title="Mathematics 数学"></a>Mathematics 数学</h2><ul><li>300 BC 几何原本 Elements</li><li>1687 自然哲学的数学原理 Philosophiae Naturalis Principia Mathematica</li><li>1965 微积分和数学分析引论 Introduction to Calculus and Analysis (Richard Courant / Fritz John)</li><li>1976 线性代数及其应用（侯自新 译）Linear Algebra and Its Applications (Gilbert Strang)</li><li>1988 具体数学 Concrete Mathematics</li><li>1995 线性代数应该这样学 Linear Algebra Done Right</li><li>(当下流行) 托马斯微积分 Thomas calculus</li><li>(当下流行) 初等概率论</li></ul><h2 id="Computability-计算理论"><a href="#Computability-计算理论" class="headerlink" title="Computability 计算理论"></a>Computability 计算理论</h2><ul><li>Alan Turing (1937) “On computable numbers, with an application to the Entscheidungsproblem”</li><li>(1979) 自动机理论、语言和计算导论  Introduction to Automata Theory, Languages, and Computation</li></ul><p>本书建议看原版</p><ul><li>1996 计算理论导论 Introduction to the Theory of Computation</li></ul><h2 id="Information-theory-信息论"><a href="#Information-theory-信息论" class="headerlink" title="Information theory 信息论"></a>Information theory 信息论</h2><ul><li>Shannon, C.E. (1948)  “A mathematical theory of communication”</li><li>Hamming, Richard (1950) “Error detecting and error correcting codes”</li><li>Huffman, D. (1952). “A Method for the Construction of Minimum-Redundancy Codes”</li><li>Ziv, J.; Lempel, A. (1977). “A universal algorithm for sequential data compression”</li><li>1991 Elements of Information Theory</li></ul><h2 id="Computer-Architecture-计算机架构"><a href="#Computer-Architecture-计算机架构" class="headerlink" title="Computer Architecture 计算机架构"></a>Computer Architecture 计算机架构</h2><ul><li>1990 Computer Architecture: A Quantitative Approach</li></ul><h2 id="Operating-System-操作系统"><a href="#Operating-System-操作系统" class="headerlink" title="Operating System 操作系统"></a>Operating System 操作系统</h2><ul><li>1974 操作系统设计与实现 Operating Systems Design and Implementation</li><li>1992 UNIX环境高级编程 Advanced Programming in the UNIX Environment</li><li>1992 现代操作系统 Modern Operating Systems</li><li>2002 深入理解计算机系统 Computer Systems:A Programmer’s Perspective</li></ul><h2 id="Compilers-编译原理"><a href="#Compilers-编译原理" class="headerlink" title="Compilers 编译原理"></a>Compilers 编译原理</h2><ul><li>1986 Compilers: Principles, Techniques and Tools</li></ul><p>在封面变成一条龙后，被称为 dragon book.</p><p><img src="http://images.gr-assets.com/books/1387666736l/703102.jpg" alt="img"></p><h2 id="Programming-Languages"><a href="#Programming-Languages" class="headerlink" title="Programming Languages"></a>Programming Languages</h2><ul><li>1978 C程序设计语言 The C programming Language</li></ul><h2 id="Programming-not-science"><a href="#Programming-not-science" class="headerlink" title="Programming ?? (not science)"></a>Programming ?? (not science)</h2><ul><li>1984 计算机程序的构造和解释 Structure and Interpretation of Computer Programs</li><li>1986 编程珠玑 Programming pearls</li><li>1993 代码大全 Code Complete</li></ul><h2 id="Algorithms-算法"><a href="#Algorithms-算法" class="headerlink" title="Algorithms 算法"></a>Algorithms 算法</h2><ul><li>1968 The Art of Computer Programming</li><li>1974 The Design and Analysis of Computer Algorithms</li><li>1983 Data Structures and Algorithms</li><li>1983 Algorithms</li><li>1990 Introduction to Algorithms</li><li>1996 Data Structures and Algorithm Analysis in C</li></ul><h2 id="Computational-complexity-theory-计算复杂度理论"><a href="#Computational-complexity-theory-计算复杂度理论" class="headerlink" title="Computational complexity theory 计算复杂度理论"></a>Computational complexity theory 计算复杂度理论</h2><ul><li>1979 Computers and Intractability: A Guide to the Theory of NP-Completeness</li><li>1994 Computational Complexity</li></ul><h2 id="Networking-网络"><a href="#Networking-网络" class="headerlink" title="Networking 网络"></a>Networking 网络</h2><ul><li>TCP/IP详解 卷1：协议</li><li>UNIX网络编程</li></ul><h2 id="Database-数据库"><a href="#Database-数据库" class="headerlink" title="Database 数据库"></a>Database 数据库</h2><ul><li>1980 Principles of Database &amp; Knowledge-Base Systems, Vol. 1: Classical Database Systems</li><li>1987 Database System Concepts</li><li>2001 数据库系统全书 Database Systems: The Complete Book</li></ul><h2 id="Software-engineering-软件工程"><a href="#Software-engineering-软件工程" class="headerlink" title="Software engineering 软件工程"></a>Software engineering 软件工程</h2><ul><li>1975 人月神话 The Mythical Man-Month: Essays on Software Engineering</li><li>1994 设计模式 Design Patterns: Elements of Reusable Object-Oriented Software</li><li>1999 程序员修炼之道 The Pragmatic Programmer: From Journeyman to Master</li></ul><p>面向对象程序设计的经典。但当你使用动态语言时，会发现部分模式是不必要的</p><ul><li>2004 软件随想录 Joe on software</li><li>重构：既有代码的改善 Refactoring: Improving the Design of Existing Code</li><li>人件</li><li>Rework</li></ul><h2 id="Artificial-Intelligence"><a href="#Artificial-Intelligence" class="headerlink" title="Artificial Intelligence"></a>Artificial Intelligence</h2><ul><li>1994 人工智能：一种现代方法 Artificial Intelligence: A modern approach</li></ul><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><ul><li><p>Probability Theory: The Logic of Science</p></li><li><p>The Elements of Statistical Learning: Data Mining, Inference, and Prediction</p></li><li><p>Information Theory, Inference and Learning Algorithms</p></li><li><p>Learning From Data: A Short Course</p></li><li><p>Pattern Recognition and Machine Learning</p></li><li><p>Probabilistic Graphical Models: Principles and Techniques</p></li><li><p>Mining of Massive Datasets</p></li><li><p>经典 <a href="http://www-bcf.usc.edu/~gareth/ISL/" target="_blank" rel="noopener">An Introduction to Statistical Learning with Applications in R</a></p></li><li><p><a href="http://www.cs.ubc.ca/~murphyk/MLbook/index.html" target="_blank" rel="noopener">Machine Learning: a Probabilistic Perspective</a> 学习曲线平滑</p></li><li><p>2016 <a href="http://www.deeplearningbook.org/" target="_blank" rel="noopener">Deep Learning(Free HTML)</a> <a href="https://github.com/HFTrader/DeepLearningBook" target="_blank" rel="noopener">pdf</a> Ian Goodfellow and Yoshua Bengio and Aaron Courville</p></li><li><p><a href="http://www.youtube.com/view_play_list?p=A89DCFA6ADACE599" target="_blank" rel="noopener">http://www.youtube.com/view_play_list?p=A89DCFA6ADACE599</a></p></li><li><p>[深度学习论文]<a href="https://github.com/HFTrader/DeepLearningBook/blob/master/DeepLearningPapers.md" target="_blank" rel="noopener">https://github.com/HFTrader/DeepLearningBook/blob/master/DeepLearningPapers.md</a></p></li><li><p><a href="https://github.com/josephmisiti/awesome-machine-learning/blob/master/books.md" target="_blank" rel="noopener">Awesome machine learning books list</a></p></li><li><p><a href="http://learningtensorflow.com/index.html" target="_blank" rel="noopener">learning tensorflow</a></p></li></ul><h2 id="膜计算-Membrane-Computing-这是什么？"><a href="#膜计算-Membrane-Computing-这是什么？" class="headerlink" title="膜计算 Membrane Computing ??? 这是什么？"></a>膜计算 Membrane Computing ??? 这是什么？</h2><ul><li>2002 膜计算导论 Membrane Computing - An Introduction</li></ul><p>参考:<br><a href="http://dl.acm.org/classics.cfm" target="_blank" rel="noopener">ACM: 经典出版物</a><br><a href="https://en.wikipedia.org/wiki/List_of_important_publications_in_computer_science" target="_blank" rel="noopener">维基百科：计算机科学重要出版物</a><br><a href="https://en.wikipedia.org/wiki/List_of_important_publications_in_theoretical_computer_science" target="_blank" rel="noopener">维基百科：理论计算机科学重要出版物</a><br><a href="http://www.goodreads.com/list/show/2205.Essential_Books_of_Computer_Science" target="_blank" rel="noopener">Goodreads: 必备计算机科学书籍列表</a><br><a href="https://www.goodreads.com/shelf/show/game-development" target="_blank" rel="noopener">Goodreads: 游戏开发</a><br><a href="https://zh.wikipedia.org/wiki/数学著作列表" target="_blank" rel="noopener">维基百科：数学著作列表</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在我学习编程的过程中，看过很多的书籍，大部分的书籍只能提供很有限的知识，有的甚至不能提供真正的“知识，充其量只是某个软件产品的使用手册而已，而且这类手册极易过时。现在，因为工作的需要，我依然会偶尔阅读这类“手册”。但我渐渐体会到了有些计算机知识是永恒的，如果从一开始我所阅读
      
    
    </summary>
    
    
      <category term="books" scheme="http://guileen.github.io/tags/books/"/>
    
  </entry>
  
</feed>
